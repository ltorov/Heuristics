# -*- coding: utf-8 -*-
"""Heurística.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10nCJO3OLM4xDGa7um0KuielhWeljREPC

#Libraries
"""

pip install xlsxwriter

from zipfile import ZipFile
import pandas as pd
import numpy as np
import matplotlib as plt
import random
import math
import time
import xlsxwriter
import os
import collections
from itertools import combinations

"""#Auxiliary methods"""

def readFile(filename):
  """
  Takes a file name and returns the p, the nodes, and a dataframe of nodes.
  """
  f = open(filename, "r")
  firstrow = list(f.readline().split("\t"))
  nodes = int(firstrow[0])
  p = int(firstrow[1])
  dfnodes = pd.read_csv(filename, sep="\t")
  dfnodes.columns= ['x','y','Capacity','Demand']
  return p, nodes, dfnodes

def euclideanDistanceMatrix(nodes,dfnodes):
  """
  Returns Dij, a matrix containing, for each (i,j), the eucledean distance from 
  node i to node j.

  Parameters:
  nodes: int
  Total amount of nodes available

  df: pandas dataframe
  Contains the (x,y) coordinates as well as the capacity and the demand for each 
  node.
  """
  Dij = np.zeros([nodes,nodes])
  for i in range(nodes):
    for j in range(nodes):
      if i<j:
        xi = dfnodes['x'][i]
        yi = dfnodes['y'][i]
        xj = dfnodes['x'][j]
        yj = dfnodes['y'][j]
        dij = math.sqrt((xj-xi)**2+(yj-yi)**2)
        Dij[i][j] = dij
  Dij = Dij + Dij.T - np.diag(np.diag(Dij))
  return Dij

def format(Xij, p, nodes, Dij, starttime, endtime):
  """
  Organizes the solution found in the format required.
  """
  f = []
  totaldist = 0
  sums = sum(Xij)
  for j in range(nodes):
    row = []
    dist = 0
    if (Xij[j][j]==1):
      row.append(j+1)
      row.append(int(sums[j]))
      for i in range(nodes):
          if (Xij[i][j]==1):
            dist = int(dist + Dij[i][j])
            row.append(i+1)
      row.append(dist)
      totaldist = totaldist+dist
      f.append(row)
  f.append([totaldist, (endtime-starttime)*1000])
  return f,totaldist

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  constructiveSolutions = []
  graspSolutions = []
  noiseSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        f, Xij, chosen, dist = constructive(p,nodes,dfnodes,Dij)
        constructiveSolutions.append(f)
        f, Xij, chosen, dist = grasp(p,nodes,dfnodes,Dij)
        graspSolutions.append(f)
        f, Xij, chosen, dist = constructiveNoise(p,nodes,dfnodes,Dij)
        noiseSolutions.append(f)
        filenames.append(filename)
  return constructiveSolutions,graspSolutions,noiseSolutions,filenames

def createExcel(solutions, filenames, excelName):
  """
  For an array of solutions returns an excel file with each solution for each
  file in a separate sheet.

  Parameters:
  solutions: array
  Array of solutions in the asked format.

  filenames: array
  Array of filenames contained in the zip files.

  excelName: string
  the asked for named for the excel files according to each method.
  """
  excel = xlsxwriter.Workbook(excelName)
  n = len(filenames)
  for m in range(n):
    filename = filenames[m].split("/",1)[1] 
    worksheet = excel.add_worksheet(filename)
    sol = solutions[m]
    for i in range(len(sol)):
      s = sol[i]
      for j in range(len(s)):
        worksheet.write(i,j,s[j])
  excel.close()
  return excel

"""#Constructive method"""

def chooseCenters(p,nodes,Dij):
  """
  Chooses the best centers, those that have the least total distance for each 
  node.
  """
  sumDij = sum(Dij)
  sumDij = sorted(range(len(sumDij)), key=lambda k: sumDij[k])
  chosen = sumDij[0:p]
  return chosen

def ranking(p,nodes,Dij,chosen):
  """
  Return a matrix containing from each node, the closest nodes to it in orden.
  """
  ranking = []
  for n in range(nodes):
    di = Dij[n]
    dists = np.zeros(p)
    for i in range(p):
      c = chosen[i]
      dists[i] = di[c]
    rank = [x for y, x in sorted(zip(dists, chosen))]
    ranking.append(rank)
  return ranking

def assignCenters(p,nodes,dfnodes,Dij, chosen):
  """
  Assigns all the other nodes to the chosen centers.

  Parameters:
  chosen: array
  Array of the centers.
  """
  Xij = np.zeros([nodes,nodes])
  rank = ranking(p,nodes,Dij,chosen)
  demand = np.array(dfnodes['Demand'])
  capacity = np.array(dfnodes['Capacity'])
  for i in range(nodes):
    if i in chosen:
      Xij[i][i] = 1
    else: 
      for j in rank[i]:
        if (j!=i):
          demandj = demand[int(j)]
          demandi = demand[i]
          capacityj = capacity[int(j)]
          if (capacityj >= demandj+demandi):
            Xij[i][int(j)] = 1
            demand[int(j)] += demandi
            demand[i] = 0
            break
  return Xij, demand, capacity

def feasible(demand,capacity):
  """
  Determines whether a solution given in the form Xij is feasible according to 
  the centers capacity and demand.
  Returns 1 when its feasible and 0 when its not.
  """
  ax = capacity-demand
  boo = True
  for a in ax:
    if a<0:
      boo = False
      break
  return boo

def constructive(p,nodes,dfnodes,Dij):
  starttime = time.time()
  chosen = chooseCenters(p,nodes,Dij)
  Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
  endtime = time.time()
  f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
  boo=feasible(demand,capacity)
  return f, Xij,chosen,totaldist

"""# GRASP algorithm"""

"""
Hiperparámetros:

numberofsolutions: int
Number of random solutions generated
"""
def randomInitialization(p, nodes, dfnodes, Dij):
  """
  Picks p random nodes as centers and assigns them to all other nodes according
  to minimum euclidean distance.
  Returns Xij, an array where ones represent where the node is assigned to.

  Parameters:
  p: int
  P medians, number of nodes to be selected
  """
  Xjj = np.ones(p, int)
  Xjj = Xjj*(-1)
  for i in range(p):
    index = random.choice(list(set([x for x in range(0, nodes-1)]) - set(Xjj)))
    Xjj[i] = int(index)
  return Xjj

def grasp(p,nodes,dfnodes,Dij,numofsolutions = 200):
  starttime = time.time()
  bestf = 0
  bestdist = 10000000000000
  bestchosen = randomInitialization(p,nodes,dfnodes,Dij)
  for i in range(numofsolutions):
    chosen = randomInitialization(p,nodes,dfnodes,Dij)
    endtime = time.time()
    Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
    f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
    boo = feasible(demand,capacity)
    if (totaldist < bestdist) and boo:
      bestdist = totaldist
      bestf = f
      bestchosen = chosen
  bestchosen = bestchosen.tolist()
  return bestf, Xij,bestchosen,bestdist

"""# Constructive with noise"""

"""
Hiperparámetros:

n: float
Parameter of uniform distribution
"""

def noise(p, nodes, dfnodes,n):
  """
  Returns the dataset with noise from a uniform distribution (-n,n).
  """
  dfnoise = dfnodes.copy()
  for i in range(nodes):
    rx = random.uniform(-n,n)
    ry = random.uniform(-n,n)
    dfnoise['x'][i] += rx
    dfnoise['y'][i] += ry
  return dfnoise

def constructiveNoise(p,nodes,dfnodes,Dij,n = 1):
  """
  Returns the dataset with noise from a uniform distribution (-n,n).
  """
  starttime = time.time()
  dfnoise = noise(p,nodes,dfnodes,n)
  Dijnoise = euclideanDistanceMatrix(nodes,dfnoise)
  chosen = chooseCenters(p,nodes,Dijnoise)
  Xij,demand,capacity = assignCenters(p,nodes,dfnoise,Dijnoise,chosen)
  endtime = time.time()
  f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
  boo = feasible(demand,capacity)
  return f,Xij,chosen,totaldist

"""# Run

Run all
"""

def main():
  constructiveSolutions,graspSolutions,noiseSolutions,filenames = readZip("pmedcap.zip")
  createExcel(constructiveSolutions,filenames,'pmedcap_LTV_Constructivo.xlsx')
  createExcel(graspSolutions,filenames,'pmedcap_LTV_GRASP.xlsx')
  createExcel(noiseSolutions,filenames,'pmedcap_LTV_ConstructivoConRuido.xlsx')
main()

"""Run only constructive"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  constructiveSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        f, Xij,chosen,totaldist = constructive(p,nodes,dfnodes,Dij)

        constructiveSolutions.append(f)
        filenames.append(filename)
  return constructiveSolutions,filenames

def main():
  constructiveSolutions,filenames = readZip("pmedcap.zip")
  createExcel(constructiveSolutions,filenames,'pmedcap_LTV_Constructivo.xlsx')
main()

"""Run only constructive with noise"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  noiseSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        f, Xij,chosen,totaldist = constructiveNoise(p,nodes,dfnodes,Dij)
        noiseSolutions.append(f)
        filenames.append(filename)
  return noiseSolutions,filenames

def main():
  noiseSolutions,filenames = readZip("pmedcap.zip")
  createExcel(noiseSolutions,filenames,'pmedcap_LTV_ConstructivoConRuido.xlsx')
  
main()

"""Run only GRASP"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  constructiveSolutions = []
  graspSolutions = []
  noiseSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        f, Xij,chosen,totaldist = grasp(p,nodes,dfnodes,Dij)
        print(totaldist,filename)
        graspSolutions.append(f)
        filenames.append(filename)
  return graspSolutions,filenames

def main():
  graspSolutions,filenames = readZip("pmedcap.zip")
  createExcel(graspSolutions,filenames,'pmedcap_LTV_GRASP.xlsx')
main()

"""#VND

Local search: change assigned medians
"""

def medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime,changes = 20):
  chosen.sort()
  bestf = f
  medians = np.zeros(nodes)
  medians[chosen] = 1
  bestchosen = chosen.copy()
  besttotaldist = totaldist
  while time.time()-starttime <runtime:
    for k in range(changes):
      if (time.time()-starttime) >=runtime:
        return bestf, besttotaldist
      random.shuffle(chosen)
      for i in chosen:
        for j in range(nodes):
          if (time.time()-starttime) >=runtime:
            return bestf, besttotaldist
          if medians[j] !=1:
            tempchosen = chosen.copy()
            ind = chosen.index(i)
            tempchosen[ind] = j
            newXij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,tempchosen)
            endtime = time.time()
            newf,newtotaldist = format(newXij, p, nodes, Dij, starttime, endtime)
            if newtotaldist < besttotaldist:
              besttotaldist = newtotaldist
              bestf = newf
              bestchosen = tempchosen
              return bestf, besttotaldist
            if (time.time()-starttime) >= runtime:
              return bestf, besttotaldist

  return bestf, besttotaldist

"""Local search: exchange assignations"""

def completeAssignation(dfnodes, p, nodes, Xij, chosen, maxdistances, totaldist,Dij,n,starttime):
  demand = np.array(dfnodes['Demand'])
  capacity = np.array(dfnodes['Capacity'])
  r = chosen.copy()
  random.shuffle(r)
  end = False
  while time.time()-starttime <runtime:
    for i in r:
      row = Xij[:,i]
      capacitycenter = capacity[i]
      dem = np.multiply(row, demand)
      demandcenter = int(sum(dem))
      dists = []
      for m in maxdistances:
        dist = Dij[m][i]
        dists.append(dist)
      distcopy = dists.copy()
      min = [x for _, x in sorted(zip(distcopy, maxdistances), key=lambda pair: pair[0])]
      cont = 0
      for m in min:
        if cont>= n:
          break
        demandm = demand[m]
        if (demandcenter+demandm)<=capacitycenter:
          Xij[m][i] = 1
          demandcenter += demandm
          ind = maxdistances.index(m)
          maxdistances.remove(m)
          del dists[ind]
        cont +=1
    end = True
    break
  return Xij, end

def assignationSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime,n = 4,iter = 50):
  chosen.sort()
  bestdist = totaldist
  bestf = f
  Fij = np.multiply(Xij, Dij)
  maxdistances = []
  tempXij = Xij.copy()
  while time.time()-starttime <runtime:
    for i in chosen:
      distances = Fij[:,i]
      maxdist = np.flip(np.argsort(distances))
      maxdist = maxdist[0:n].tolist()
      maxdistances.append(maxdist)
      for m in maxdist:
        tempXij[m][i] = 0
    maxdistances = [item for sublist in maxdistances for item in sublist]
    maxdistances.sort()
    bestdist = totaldist
    bestf = f
    for i in range(iter):
      newXij,end = completeAssignation(dfnodes, p, nodes, tempXij,chosen,maxdistances, totaldist, Dij,n,starttime)
      if end:
        endtime = time.time()
        newf,newtotaldist = format(newXij, p, nodes, Dij, starttime, endtime)
        if newtotaldist<bestdist:
          bestdist = newtotaldist
          bestf = newf
    break
  return bestf, bestdist

"""Local search: exchange pairs"""

def feasibleChange(p, nodes, dfnodes, Xij, nodem, noden, chosen):
  demand = np.array(dfnodes['Demand'])
  capacity = np.array(dfnodes['Capacity'])
  newdemand = np.zeros(nodes)
  for c in chosen:
    newdemand[c] = sum(Xij[c]*demand)
  boo = feasible(demand, capacity)
  return boo

def pairSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime):
  besttotaldist = totaldist
  bestf = f
  assignation = []
  bestXij = Xij
  while time.time()-starttime <runtime:
    for c in chosen:
      assigned = Xij[:,c]
      assigned = ((np.nonzero(assigned))[0]).tolist()
      assignation.append(assigned)
    for i in range(p):
      for j in range(1,p):
        while time.time()-starttime <runtime:
          if i<j:
            assignedi,assignedj = assignation[i],assignation[j]
            choseni,chosenj = chosen[i],chosen[j]
            for m in assignedi:
              if choseni != m and choseni != m:
                for n in assignedj:
                  if (choseni != n and choseni != n) and (n!=m):
                    newXij = Xij.copy()
                    newXij[m][choseni] = 0
                    newXij[n][choseni] = 1
                    newXij[n][chosenj] = 0
                    newXij[m][chosenj] = 1
                    boo = feasibleChange(p, nodes, dfnodes, newXij, m, n, chosen)
                    if boo:
                      endtime = time.time()
                      newf,newtotaldist = format(newXij, p, nodes, Dij, starttime, endtime)
                      if newtotaldist< totaldist:
                        bestf = newf
                        besttotaldist = newtotaldist
                        bestXij = newXij
                        assignation = []
                        for c in chosen:
                          assigned = bestXij[:,c]
                          assigned = ((np.nonzero(assigned))[0]).tolist()
                          assignation.append(assigned)
          break
    break
  return bestf, besttotaldist

"""Local search"""

def localSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f):
  starttime = time.time()
  besttotaldist = totaldist
  while time.time()-starttime <runtime:
    """
    assignationf, assignationDist = assignationSearch(p,nodes,dfnodes,Dij,Xij,chosen,besttotaldist,f,starttime)
    if assignationDist<besttotaldist:
      f = assignationf.copy()
      besttotaldist = assignationDist
    pairf, pairDist = pairSearch(p,nodes,dfnodes,Dij,Xij,chosen,besttotaldist,f,starttime)
    if pairDist<besttotaldist:
      f = pairf.copy()
      besttotaldist = pairDist
    """
    medianf, medianDist = medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,besttotaldist,f,starttime)
    if medianDist<besttotaldist:
      f = medianf.copy()
      besttotaldist = medianDist

  endtime = time.time()
  f[p][1] = (endtime-starttime)*1000
  return f, besttotaldist

"""#Run

GRASP initial solution
"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  GRASPSolutions = []
  localSearchSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        fgrasp, Xij,chosen,totaldist = grasp(p,nodes,dfnodes,Dij,numofsolutions = 2000)
        print("grasp ",totaldist)
        GRASPSolutions.append(fgrasp)
        f,dist = localSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,fgrasp)
        print("local search ",dist)
        localSearchSolutions.append(f)
        filenames.append(filename)
  return GRASPSolutions,localSearchSolutions,filenames

runtime = 60
def main():
  GRASPSolutions, localSearchSolutions, filenames = readZip("pmedcap.zip")
  createExcel(localSearchSolutions,filenames,'pmedcap_LTV_BúsquedaLocal.xlsx')
main()

"""#Search

Simulated annealing
"""

def tempFunction(temp,g):
  return temp * g

def acceptanceProbability(dist, bestDist, temp ):
  delta = dist-bestDist
  if delta <= 0:
    return 1
  else:
    return math.exp(-delta/temp)

def simulatedAnnealing(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime,T0=50,L=50,g=0.7):
  bestf = f
  bestdist = totaldist
  temp = T0
  while (time.time()-starttime) <runtime:
    for i in range(L):
      newf, newdist = medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime)
      rand = acceptanceProbability(newdist,bestdist,temp)
      if rand >= random.random():
        bestf = newf
        bestdist = newdist
      temp = tempFunction(temp,g)
    break
  return bestf,bestdist

"""LNS destroy-repair"""

def reassignation(dfnodes, p, nodes, Xij, chosen, reassignation, totaldist,Dij,n,starttime):
  demand = np.array(dfnodes['Demand'])
  capacity = np.array(dfnodes['Capacity'])
  r = chosen.copy()
  random.shuffle(r)
  end = False
  while time.time()-starttime <runtime:
    for m in reassignation:
      boo = False
      dists = []
      for i in r:
        dist = Dij[m][i]
        dists.append(dist)
      min = [x for _, x in sorted(zip(dists, r), key=lambda pair: pair[0])]
      for i in min:
        if not boo:
          row = Xij[:,i]
          capacitycenter = capacity[i]
          dem = np.multiply(row, demand)
          demandcenter = int(sum(dem))
          demandnode = demand[m]
          if (demandcenter + demandnode) < capacitycenter:
            Xij[m][i] = 1
            boo = True
    end = True
    break
  return Xij, end

def destroyRepair(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime,percentage = 0.2,iter = 150):
  toReassign = int(nodes*percentage)
  bestf = f
  bestdist= totaldist
  while (time.time()-starttime) <runtime:
    for j in range(iter):
      newXij = Xij.copy()
      reassign = []
      for i in range(toReassign):
        index = random.choice(list(set([x for x in range(0, nodes-1)]) - set(chosen)-set(reassign)))
        reassign.append(int(index))
      for i in reassign:
        newXij[i] = np.zeros(nodes)
      newXij,end = reassignation(dfnodes, p, nodes, newXij, chosen, reassign, totaldist,Dij,int(toReassign/p),starttime)
      if end:
        endtime = time.time()
        newf,newtotaldist = format(newXij, p, nodes, Dij, starttime, endtime)
        if newtotaldist < bestdist:
          bestdist = newtotaldist
          bestf = newf
    break
  return bestf,bestdist

"""Multiple initial solutions"""

def initialSolution(p,nodes,dfnodes,Dij,Xij,chosen,starttime):
  while (time.time()-starttime) <runtime:
    chosen = (randomInitialization(p,nodes,dfnodes,Dij)).tolist()
    Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
    endtime = time.time()
    f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
    boo = feasible(demand,capacity)
    break
  return f,totaldist

"""Search"""

runtime = 60
def search(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f):
  starttime = time.time()
  bestdist = totaldist
  bestf = f
  while (time.time()-starttime) <runtime:
    newf,newdist = initialSolution(p,nodes,dfnodes,Dij,Xij,chosen,starttime)
    if newdist<bestdist:
      bestf = newf
      bestdist = newdist
    newf, newdist = destroyRepair(p,nodes,dfnodes,Dij,Xij,chosen,bestdist,bestf,starttime)
    if newdist<bestdist:
      bestf = newf
      bestdist = newdist
    newf,newdist = simulatedAnnealing(p,nodes,dfnodes,Dij,Xij,chosen,bestdist,bestf,starttime)
    if newdist<bestdist:
      bestf = newf
      bestdist = newdist
  endtime = time.time()
  bestf[p][1] = (endtime-starttime)*1000
  return bestf, bestdist

"""#Run"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  constructiveSolutions = []
  searchSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        fconstructive, Xij,chosen,totaldist = constructive(p,nodes,dfnodes,Dij)
        constructiveSolutions.append(fconstructive)
        print("constructive ",totaldist)
        f,dist = search(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,fconstructive)
        searchSolutions.append(f)
        print("search ",dist)
        filenames.append(filename)
  return constructiveSolutions,searchSolutions,filenames
runtime = 5*60
def main():
  constructiveSolutions, searchSolutions, filenames = readZip("pmedcap.zip")
  createExcel(searchSolutions,filenames,'pmedcap_LTV_Búsqueda.xlsx')
main()

"""#Evolutivo

"""

def completeCenters(p,nodes,Dij, Chosen):
  """
  Chooses the best centers, those that have the least total distance for each 
  node.
  """
  sumDij = sum(Dij)
  sumDij = sorted(range(len(sumDij)), key=lambda k: sumDij[k])
  l = len(Chosen)
  chosen = sumDij[0:p-l] + Chosen
  return chosen

def completeChoice(p, nodes, dfnodes, Dij, runtime, starttime, Chosen, bestDist, bestf, bestChosen, bestXij):
  chosen = completeCenters(p,nodes,Dij,Chosen)
  Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
  endtime = time.time()
  f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
  if totaldist<bestDist:
    return f, totaldist, Xij
  return bestf, bestDist, bestXij

def chooseChoice(p, nodes, dfnodes, Dij, runtime, starttime, mostCommonMedian, bestDist, bestf, bestChosen, bestXij):
  while (time.time() - starttime) < runtime:
    comb = combinations(mostCommonMedian, p)
    for c in list(comb):
      combChosen = list(c)
      if (time.time()-starttime) >= runtime:
        return bestf, bestDist, bestChosen
      Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,combChosen)
      endtime = time.time()
      f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
      if totaldist < bestDist:
        bestDist = totaldist
        bestf = f
        bestXij = Xij
      if (time.time()-starttime) >= runtime:
        return bestf, bestDist, bestXij

def similaritiesCheck(p,nodes,dfnodes,Dij,runtime,starttime, bestf,bestDists,bestXij, bestChosen):
  while (time.time()-starttime) <runtime:
    mostCommonMedian = []
    Chosen = ((np.array(bestChosen)).flatten()).tolist()
    if len(Chosen) == len(set(Chosen)):
        repeatedboo = False
    else:
        repeatedboo = True
    if (not repeatedboo) or ((time.time()-starttime) >= runtime):
      return bestf[0],bestDists[0],bestXij[0]
    mostCommonMedian = [item for item, count in collections.Counter(Chosen).items() if count > 1]
    l = len(mostCommonMedian)
    if l == p:
      newChosen = mostCommonMedian
      Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,newChosen)
      endtime = time.time()
      f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
      if bestDists[0]> totaldist:
        return f, totaldist, Xij
      else: 
        return bestf[0],bestDists[0],bestXij[0]   
    elif l < p:
      return completeChoice(p, nodes, dfnodes, Dij, runtime, starttime, mostCommonMedian, bestDists[0], bestf[0], bestChosen[0], bestXij[0])
    else:
      return chooseChoice(p, nodes, dfnodes, Dij, runtime, starttime, mostCommonMedian, bestDists[0], bestf[0], bestChosen[0], bestXij[0])


def genetic(p,nodes,dfnodes,Dij,runtime,numinitialSolutions = 6, M = 5):
  starttime = time.time()
  finitialSolutions,XijinitialSolutions,distinitialSolutions,choseninitialSolutions = [],[],[],[]
  while (time.time()-starttime) <runtime:
    for i in range(numinitialSolutions):
      f, Xij,chosen,totaldist = grasp(p,nodes,dfnodes,Dij,numofsolutions = 500)
      print('grasp', totaldist)
      medianf, medianDist = medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,totaldist,f,starttime, changes=200)
      print('median search', medianDist)
      finitialSolutions.append(medianf)
      XijinitialSolutions.append(Xij)
      distinitialSolutions.append(medianDist)
      choseninitialSolutions.append(chosen)
    bestSolutions = (np.argsort(distinitialSolutions))[:M]
    bestf,bestDists,bestXij,bestChosen = [],[],[],[]

    for i in range(M):
      bestf.append(finitialSolutions[bestSolutions[i]])
      bestDists.append(distinitialSolutions[bestSolutions[i]])
      bestXij.append(XijinitialSolutions[bestSolutions[i]])
      bestChosen.append(choseninitialSolutions[bestSolutions[i]])
    if ((time.time()-starttime) >= runtime):
      return bestf[0], bestDists[0]
    bestf,bestDist,bestXij = similaritiesCheck(p,nodes,dfnodes,Dij,runtime,starttime, bestf,bestDists,bestXij,bestChosen)
    while ((time.time()-starttime) < runtime):
      medianf, medianDist = medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,bestDist,bestf,starttime, changes=200)
      print('median search', medianDist)
      if medianDist<bestDist:
        bestDist = medianDist
        bestf = medianf
        boo = True
        while boo:
          if (time.time()-starttime) >= runtime:
            return bestf, bestDist
          medianf, medianDist = medianSearch(p,nodes,dfnodes,Dij,Xij,chosen,bestDist,bestf,starttime, changes = 200)
          print('median search', medianDist)
          if medianDist > bestDist:
            boo = False
          else:
            bestDist = medianDist
            bestf = medianf
    return bestf, bestDist

"""#Run

"""

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  geneticSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        starttime = time.time()
        f,totaldist = genetic(p,nodes,dfnodes,Dij,runtime)
        endtime = time.time()
        f[p][1] = (endtime-starttime)*1000
        geneticSolutions.append(f)
        print("genetic ",totaldist)
        filenames.append(filename)
  return geneticSolutions,filenames
runtime = 60*5
def main():
  geneticSolutions, filenames = readZip("pmedcap.zip")
  createExcel(geneticSolutions,filenames,'pmedcap_LTV_Híbrido.xlsx')
main()